% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solving-functions.R
\name{solve_in_range}
\alias{solve_in_range}
\title{Simulate ODEs}
\usage{
solve_in_range(
  rng,
  varname,
  func,
  initialvalue,
  params = list(),
  control = list(),
  kind = "ode",
  allsamples = FALSE
)
}
\arguments{
\item{rng}{The range of values the control parameter takes.}

\item{varname}{The name of the control parameter. Must match a parameter in params list.}

\item{func}{The dynamical model, a function returning a derivative}

\item{initialvalue}{A vector or scalar of initial value(s).}

\item{params}{A list of function parameters, including the adjacency matrix if necessary.}

\item{control}{A list including some subset of nsamples, spacing, deltaT, times, ncores, or silent, depending on the application.}

\item{kind}{To solve with or without noise}

\item{allsamples}{Not currently used}
}
\value{
An L x N matrix of final values, where L is the length of `rng` and N is the length of `initialvalue`.
}
\description{
Simulate a system of ODEs across a range of a control parameter.
}
\details{
Solves an ODE or SDE across a range of parameter values. If `kind = "ode"`, requires deSolve.
}
\examples{
library(parallel)
ncores <- detectCores()-1
library(igraph)
library(deSolve)
g <- readRDS("../data/dolphin.rds")
N <- vcount(g)
A <- as_adj(g, "both", sparse = FALSE)
k <- degree(g)
times <- 0:15
params <- c(.doublewell, list(A = A))
control <- list(times = times, ncores = ncores)
X <- solve_in_range(params$Ds, "D", doublewell, rep(params$xinit.low, N), params, control, "ode")
}
