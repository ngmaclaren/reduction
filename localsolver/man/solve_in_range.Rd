% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solving-functions.R
\name{solve_in_range}
\alias{solve_in_range}
\title{Simulate ODEs}
\usage{
solve_in_range(
  rng,
  varname,
  func,
  initialvalue,
  params = list(),
  control = list(),
  kind = "ode",
  allsamples = FALSE
)
}
\arguments{
\item{rng}{The range of values the control parameter takes.}

\item{varname}{The name of the control parameter. Must match a parameter in params list.}

\item{func}{The dynamical model, a function returning a derivative}

\item{initialvalue}{A vector or scalar of initial value(s).}

\item{params}{A list of function parameters, including the adjacency matrix if necessary.}

\item{control}{A list including some subset of nsamples, spacing, deltaT, times, ncores, or silent, depending on the application.}

\item{kind}{To solve with or without noise}

\item{allsamples}{Not currently used}
}
\value{
An L x N matrix of final values, where L is the length of `rng` and N is the length of `initialvalue`.
}
\description{
Simulate a system of ODEs across a range of a control parameter.
}
\details{
Solves an ODE or SDE across a range of parameter values. If `kind = "ode"`, requires deSolve.
}
\examples{
library(stats)
library(deSolve)
library(localsolver)

## Generate an adjacency matrix
library(igraph)
g <- largest_component(sample_gnm(10, 20, directed = FALSE, loops = FALSE))
A <- as_adj(g, "both", sparse = FALSE)
N <- vcount(g)

## solve_in_range() assumes mclapply() is available, so may not work on Windows
library(parallel)
ncores <- detectCores()-1

params <- c(.doublewell, list(A = A))
params$sigma <- 0.1

control <- list(times = 0:10, deltaT = 0.01, ncores = ncores)
simtimes <- seq(control$times[1], control$times[length(control$times)], by = control$deltaT) # for comparison between ode() and sde()

X.ode <- solve_in_range(params$Ds, "D", doublewell, rep(params$xinit.low, N), params, control, "ode")
X.sde <- solve_in_range(params$Ds, "D", doublewell, rep(params$xinit.low, N), params, control, "sde")

xlim <- range(params$Ds)
ylim <- range(c(X.ode, X.sde))

matplot(params$Ds, X.ode, xlim = xlim, ylim = ylim, xlab = "D", ylab = "x", lty = 1, col = 1, lwd = 1, type = "l")
matlines(params$Ds, X.sde, lty = 1, col = 2, lwd = 1)
}
